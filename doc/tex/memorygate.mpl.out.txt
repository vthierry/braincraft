    |\^/|     Maple 2025 (X86 64 LINUX)
._|\|   |/|_. Copyright (c) Maplesoft, a division of Waterloo Maple Inc. 2025
 \  MAPLE  /  All rights reserved. Maple is a trademark of
 <____ ____>  Waterloo Maple Inc.
      |       Type ? for help.
# Convergence of the memory gate

> h := x -> 1/(1+exp(-4*x)):
> Heavside(0) := 1/2: H := Heaviside:

## Programmatoid implementation

> eq :=  {o[t] = H(i[t] - i_l[t] - 1/2) + H(o[t - 1] + i_l[t] - 3/2)}:
> ok := {}:
> for v_i in {0, 1} do for v_o in {0, 1} do
>   eq_io := {i_l[t] = 1, i[t]  = v_i, o[t - 1] = v_o}:
>   ok := ok union subs(eq_io union subs(eq_io, eq), {o[t] = o[t-1]}):
> od od: map(evalb, ok);
                                     {true}


## Neuronoid binary implementation 

> eq_o := {o[t] = h(omega * (i[t] - i_l[t] - 1/2) ) + h(omega * (o[t - 1] + i_l[t] - 3/2))}:
> eq_e := {e[t] = beta + h(omega * (e [t-1] - 1/2))}:

### Generates all the four cases
> eqs := {}:
> for e_i in {{i[t]  = 0}, {i[t]  = 1}} do
>   for e_o in {{o[0] = 0, o[t] = e[t], o[t-1] = e[t-1]}, {o[0] = 1, o[t] = 1 - e[t], o[t-1] = 1 - e[t-1]}}  do
>     eq := {i_l[t] = 1} union e_i union e_o union {subs(e_i union e_o, beta =  (1 - 2 * o[0]) *  h(-(3/2 - i[t]) * omega))}:
> eqs := {op(eqs), eq} od od:

### Verifies the formula
> ok := {}: for eq in eqs do 
>     eq_e_ := solve(subs(eq, eq_o), {e[t]});
>     ok := {op(ok), {simplify(subs(solve(subs(eq, eq_o), {e[t]}), e[t]) - subs(eq_e, eq, e[t]))}}
> od: evalb(ok = {{0}});
                                      true


### Calculates e[1]
> map(eq->{op(subs(eq, {i_t = i[t], o_0 = o[0]})),
>   op(map(u->op(1,u) = series(op(2, u), exp_omega=infinity, 6), subs(exp(omega)=exp_omega, expand(subs(eq, {subs(eq, e[t-1] = (2 - i[t] - o[0]) * err/exp(omega)^2)}, eq_e)))))},
> eqs) assuming err > 0;
                               1        8 err omega - 1         1
{{i_t = 0, o_0 = 0, e[t] = ---------- + --------------- + O(----------)},
                                    2              4                 6
                           exp_omega      exp_omega         exp_omega

                                  1        4 err omega - 1         1
    {i_t = 0, o_0 = 1, e[t] = ---------- + --------------- + O(----------)},
                                       2              4                 6
                              exp_omega      exp_omega         exp_omega

                                  2        4 err omega - 2         1
    {i_t = 1, o_0 = 0, e[t] = ---------- + --------------- + O(----------)},
                                       2              4                 6
                              exp_omega      exp_omega         exp_omega

    {i_t = 1, o_0 = 1, e[t] = 0}}

> quit
memory used=18.3MB, alloc=43.3MB, time=0.09
