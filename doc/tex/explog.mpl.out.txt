    |\^/|     Maple 2025 (X86 64 LINUX)
._|\|   |/|_. Copyright (c) Maplesoft, a division of Waterloo Maple Inc. 2025
 \  MAPLE  /  All rights reserved. Maple is a trademark of
 <____ ____>  Waterloo Maple Inc.
      |       Type ? for help.
# Exp-log transform i[1..K] -> o between average and max

> o_i := log(sum(exp(mu * i[k]), k = 1..K)/K)/mu:

## Series at µ = 0
> o_i_0 := series(o, mu = 0, 2);
                                   o_i_0 := o


## Series at µ = +oo

### The i[1] extracted formula, assuming withour loss of generality i[1] >= i[2] …
> rho := log(1 + sum(exp(-mu * (i[1] - i[k])), k = 2..K)):
> o_i_oo := i[1]  - log(K) / mu + rho / mu:

### Verification for a given K, mu = 1 without loss of generality
> evalb(expand(eval(subs(mu = 1, K = 11, exp(o_i) = exp(o_i_oo)))));
                                      true


### Verification of the limit in the typical case K = 2 and or up to a monotone transformation
> rho_oo_2 := series(eval(subs(K = 2, rho)), mu = infinity, 1) assuming i[1] > i[2];
                                                           2
                              exp(mu i[2])     exp(mu i[2])
                  rho_oo_2 := ------------ + O(-------------)
                              exp(mu i[1])                 2
                                               exp(mu i[1])

> rho_oo_11:= series(subs(map(k->i[k] = i[1] - k^(1/2), {$2..11}), eval(subs(K = 11, rho))), mu = infinity, 1);
                                    1                1
                  rho_oo_11 := ------------ + O(------------)
                                       1/2              1/2
                               exp(mu 2   )     exp(mu 3   )


### Compute the bounds for i[k] in [-1, 1]
> simplify([log(sum(exp(-mu), k = 1..K)/K) / mu, log(sum(exp(mu), k = 1..K)/K) / mu]) assuming mu > 0;
                                    [-1, 1]

> simplify(solve({log(1+nu_min)/mu = log(sum(exp(-mu), k = 1..K)/K), log(1+nu_max)/mu = log(sum(exp(mu), k = 1..K)/K)}, {nu_min, nu_max}));
                                2                            2
                {nu_max = exp(mu ) - 1, nu_min = -1 + exp(-mu )}


## Plot the function for some µ	
> plotsetup(jpeg, plotoutput="explog.jpg", plotoptions="width=600,height=600"):
> plot(map(mu_->subs(i[1]=x, i[2]=1/2,mu=mu_,eval(subs(K=2, o_i))),[0.01, 0.1, 1,10,100]),x=-1..1,color=["Black", "Orange", "Red","Green","Blue"]);
> plotsetup(x11):

## Sigmoid function approximation of exp and log
> h := x -> 1/(1+exp(-4*x)):

> h_ := x -> a + b * h(x - 1) + c * h(x):
> sl_exp := solve({h_(-1) = exp(-1), h_(0) = exp(0), h_(1)=exp(1)}, {a, b, c}):
> h_exp:= unapply(subs(sl_exp, h_(x)), x):
> err_exp := sum(evalf(abs(h_exp(x/50)-exp(x/50))), x = -50..50)/101;
                            err_exp := 0.05453295796

> plotsetup(jpeg, plotoutput="expneuronoid.jpg", plotoptions="width=600,height=600"):
> plot([exp, h_exp, h_exp-exp],-1..1, color=["Blue", "Green", "Red"]);
> plotsetup(x11):
> evalf(sl_exp);
              {a = 0.3450482185, b = 2.339035262, c = 1.225762805}


> log1 := x -> log(1 + x):
> h_ := x -> a + b * h(x/10) + c * h(x/2):
> sl_log := solve({h_(0) = log1(0), h_(10) = log1(10), h_(2) = log1(2)}, {a, b, c}):
> h_log  := unapply(subs(sl_log , h_(x)), x):
> err_log := sum(evalf(abs(h_log(x/100)-log1(x/100))), x = 0..100)/101;
                            err_log := 0.04985411867

> plotsetup(jpeg, plotoutput="logneuronoid.jpg", plotoptions="width=600,height=600"):
> plot([log1, h_log, h_log-log1],0..10, color=["Blue", "Green", "Red"]);
> plotsetup(x11):
> evalf(sl_log);
             {a = -2.477319052, b = 4.415815141, c = 0.5388229647}


> quit
memory used=221.3MB, alloc=108.3MB, time=1.03
